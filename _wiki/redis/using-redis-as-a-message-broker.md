---
layout  : wiki
title   : Using Redis as a Message Broker
summary : 
date    : 2025-03-17 15:05:00 +0900
updated : 2025-03-17 15:05:00 +0900
tag     : redis message-broker
toc     : true
comment : true
public  : true
parent  : [[/redis]]
latex   : true
---
* TOC
{:toc}

## Using Redis as a Message Broker

최근의 서비스 아키텍처 → 여러 모듈들의 **Loose Coupling** 선호 → 모듈간 탄탄한 **상호 작용** 필요 → 효율적인 **메시징 솔루션(메시지 브로커)** 필요성

- 예기치 못한 장애 → 통신이 안되는 상황 고려 필요
    - **비동기(async) 통신** 사용 권장
    - 동기(sync) 통신 횟수를 줄이는 것이 바람직
- 서비스 간 통신이 불가능한 상황이 바로 장애로 이어지지 않도록, 보낸 메시지를 쌓아 둔 뒤 나중에 처리할 수 있는 채널이 필요함
    - 메시지 브로커의 역할

## Message Queue and Event Stream

- [Message Queue](https://en.wikipedia.org/wiki/Message_queue)
    - 생산자(producer): 데이터를 생성하는 쪽
    - 소비자(consumer): 데이터를 수신하는 쪽
- **이벤트 스트림(Event Stream)**
    - 발행자(publisher): 데이터를 생성하는 쪽
    - 구독자(subscriber): 데이터를 조회하는 쪽
- 주요 차이점
    - **방향성**
        - 메시지 큐의 생산자는 소비자의 큐로 데이터를 직접 **Push**
            - e.g) 2개의 서비스에 같은 메시지를 보내야할 때 메시징 큐에서는 각각 다른 메시징 큐에 **각각 데이터를 Push**
        - 이벤트 스트림의 생산자는 스트림의 특정 저장소에 하나의 메시지를 보낼 수 있고, 메시지를 읽어가고자 하는 소비자들은 스트림에서 같은 **메시지를 Pull**해 갈 수 있다.
    - 데이터의 **영속성**
        - 메시지 큐에서는 소비자가 데이터를 읽어가면 큐에서 **데이터를 삭제**
            - e.g) 메시지를 보내는 도중, 새로운 소비자가 추가된다면 소비자는 새롭게 추가된 이후의 이벤트만 확인 가능
        - 이벤트 스트림에서는 바로 삭제되지 않고, 설정에 따라 **특정 기간 동안 저장될 수 있음**
            - e.g) 스트림에 쌓인 데이터는 일정 기간 동안 지워지지 않기 때문에 새로 추가된 서비스도 스트림에 남아있는 이전 데이터의 히스토리를 볼 수 있음
- 메시지 큐는 **일대일(1:1)** 상황에서 유용하게 사용
- 스트림은 **다대다(n:n)** 상황에서 유리함